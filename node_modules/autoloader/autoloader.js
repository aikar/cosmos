/*
 *  This package exports one function: namespace
 *  in order to create a system of namespace loading 
 *  from a given directory. Directories and files are
 *  loaded into a proxy object in order to provide a
 *  system for loading additional files and directories
 *  the namespace.
 *
 *  This system does not proxy scalar values on an object
 *  because of the 
 *
 */
var Proxy = require("harmonyproxy"),
  fs = require("fs"),
  sys = require("sys"),
  path = require("path"),
  undef, extensions = [".js", ".class.js"];

function isFunction(fn) {
  return !!(typeof fn == 'function');
}

function isScalar(fn) {
  switch (typeof fn) {
    case "function":
    case "object":
      return false;
  }
  return true;
}

function inPath(file) {
  var i = 0, l = extensions.length;

  for (;i<l;++i) {
    if (path.existsSync(file + extensions[i])) {
      return file + extensions[i];
    }
  }
  return false;
}
// make sure its loaded first

require('joose');

var LAST_CLASS;

var orig = {};
var overloaded = {};
// joose globals to overload.
var overload = ['Class', 'Role','Singleton', 'LazyClass', 'LazyRole', 'Module'];


overload.forEach(function (key) {
  orig[key]  = global[key];
  overloaded[key] = function() {
    var args = [].slice.call(arguments);
    if (typeof args[0] == 'string') {
      args.shift();
    }
    LAST_CLASS = orig[key].apply(this, args);
    return LAST_CLASS;
  }
});

function overloadJoose() {

  overload.forEach(function (key) {
    global[key] = overloaded[key];
  });
}
function restoreJoose() {  
  overload.forEach(function (key) {
    global[key] = orig[key];
  });
}
function loadJooseClass(file) {
  LAST_CLASS = null;
  overloadJoose();
  var obj;
  if ((file = inPath(file)) !== false) {
    obj = require(file);
  }
  restoreJoose();
  if ((!obj || !Object.keys(obj).length) && LAST_CLASS) {
    obj = LAST_CLASS;
  }
  return obj;
}
function namespace(filePath, properties) {
  properties = properties || {};
  
  var scalar = isScalar(properties),
    func = isFunction(filePath),
    handlers = {
      get: function(rec, name) {
        /*try {
          a.b = 1;
        } catch (e) {
          //console.error("get", filePath, name);
          //console.error(e.stack)
        }*/
        if (name === "valueOf" || name === "toString") {
          return function(){
            //console.error("returning valueof")
            return properties[name].call(this);
          };
        }
        if (!(name in properties)) {
          if (func) {
            properties[name] = filePath(name, properties);
          } else {
            //sys.puts(name);
            var file = path.join(filePath, name),
              stat, obj;
            
            obj = loadJooseClass(file);
            
            if (!obj) {
              try{
                // would work if it was a directory
                stat = fs.statSync(file);
                // this allows you to use an 
                // object as a namespace as well
                return namespace(file);
              } catch(e) {
                return undef;
              }
            } else {
              properties[name] = obj;
            }
          }
        }
        if (!isScalar(properties[name]) && !Proxy.isProxy(properties[name])) {
          return namespace(path.join(filePath, name), properties[name]);
        }
        //console.error("returning", properties[name]);
        return properties[name];
      
      },
      has: function(name) {
        //console.error("has", name);
        return name === "valueOf" || 
            name === "toString" || 
            inPath(path.join(filePath, name));
      },
      set: function(rec, name, value) {
        //console.log("setting", name, value)
        properties[name] = value;
      },
      "delete": function(name) {
        delete properties[name];
      },
      enumerate: function() {
        return Object.keys(properties);
      },
      fix: function() {
        return undef;
      }
    };
  
  if (isFunction(properties)) {
    return Proxy.createFunction(handlers, function(name) {
      //console.error("calling", filePath, name)
      return properties.apply(this, arguments);
    }, function() {
      //console.error("constructing", filePath);
      var instance = Object.create(properties.prototype);
      properties.apply(instance, arguments);
      return instance;
    });
  } else {
    return Proxy.create(handlers, properties.constructor.prototype);
  }
};
global.registerAutoloader = function(globalName, path) {
  var cls = loadJooseClass(path + '/' + globalName);
  global[globalName] = namespace(path, cls);
}



